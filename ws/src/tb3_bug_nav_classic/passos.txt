1. No host

- xhost +local:
- cd classic_nav
- docker-compose down
- docker-compose up -d --build

2. No container

- docker exec -it tb3_nav bash
- source /opt/ros/humble/setup.bash
- colcon build --packages-select tb3_bug_nav_classic
- source /root/ws/install/setup.bash
- ros2 launch tb3_bug_nav_classic bug2_classic.launch.py world:=/root/ws/src/tb3_bug_nav_classic/worlds/bug_world.world gui:=true

Dicas de desempenho (já aplicadas)

- Dockerfile agora instala Mesa GL (libgl1-mesa-dri, mesa-utils etc.) para reduzir erros GL.
- docker-compose mapeia /dev/dri e ~/.Xauthority, e define LIBGL_DRI3_DISABLE=1.
- O mundo tem sombras desativadas e ajustes leves de física.

Se a GUI ainda estiver pesada

- Teste com:
    - export LIBGL_ALWAYS_SOFTWARE=1 (dentro do container, fallback de software, mas mais compatível).
    - Reduza plugins/visuais na GUI (sem sombras, UI mínima).
- Se tiver GPU NVIDIA, posso ajustar o compose para usar runtime: nvidia e alavancar GPU (vai voar).

O que esperar

- Gazebo abre seu bug_world1.world.
- O waffle aparece na posição do user_spot_light_0.
- /bug_state mudará conforme Bug1: HIT → FOLLOW_BOUNDARY → GO_TO_LEAVE → MOTION_TO_GOAL.
- Gravação da bag: ros2 bag record -o bug_run /odom /scan /cmd_vel /bug_state

Quer que eu faça o mesmo mapeamento de luzes (start/goal) para o Tangent-Bug? Posso adaptar o tangent_classic.launch.py também.
